# HG changeset patch
# Date 1413517017 14400
# User Patrick Cloke <clokep@gmail.com>
# Parent 5b003759bded6110b39348f04276c878f5f7591a
Clean up xml2sdp.

diff --git a/chat/protocols/xmpp/xmpp-jingle.jsm b/chat/protocols/xmpp/xmpp-jingle.jsm
--- a/chat/protocols/xmpp/xmpp-jingle.jsm
+++ b/chat/protocols/xmpp/xmpp-jingle.jsm
@@ -3,379 +3,318 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const EXPORTED_SYMBOLS = ["Jingle"];
 
 Components.utils.import("resource:///modules/xmpp-xml.jsm");
 
 const Jingle = {
   sdp2xml: function sdp2xml(aOffer) {
-    // NOTE: The SDP offer folows the RFC-4566: Session Description Protocol.
+    // NOTE: The SDP offer follows the RFC-4566: Session Description Protocol.
     // Using XEP-0320: Jingle RTP Session.
 
-    // This is the output variable which contains the array of content node to
-    // be sent with Jingle stanza.
-    let contentNodes = [];
-
     // SDP session description consists of a session-level section followed by
     // zero or more media-level sections.
-    let sessionDesc = aOffer.split("m=");
-
-    /* "ice-ufrag" and "ice-pwd" attributes convey the username fragment and
-     * password used by ICE for message integrity. See RFC 5245, Section 15.4.
-     * e.g. [a=ice-ufrag:0c838e8e]
-     */
-    let ufrag;
-    // eg. [a=ice-pwd:1ef8fe1ef670d3dd89098b03dac4b4ed]
-    let pwd;
-    /* The fingerprint is the result of a hash function of the certificates
-     * used in the DTLS-SRTP negotiation. This line creates a binding between
-     * the signaling and the certificates used in DTLS.
-     * e.g. [a=fingerprint:sha-256 2B:6E:6A:8D:...]
-     */
-    let shaHash;
-    let fingerprintData;
+    let sections = aOffer.split("m=");
 
     // The session-level section contains the version, user name, type of call,
     // timestamp, ufrag, password, fingerprint and other attributes.
-    let headerLines = sessionDesc[0].split("\r\n");
-    for (let header of headerLines) {
-      let params = header.split(":");
-
-      // It is the ufrag attribute of transport node.
-      if (params[0] == "a=ice-ufrag")
-        ufrag = params[1];
-      // It is the pwd attribute of the transport node.
-      else if (params[0] == "a=ice-pwd")
-        pwd = params[1];
-      // It gets the fingerprint data and sha hash information of the
-      // fingerprint node.
-      else if (params[0] == "a=fingerprint") {
-        shaHash = params[1].split(" ")[0];
-        fingerprintData = header.split(" ")[1];
+    let ufrag, pwd, hashType, fingerprintData;
+    let headers = sections.shift().split("\r\n");
+    for (let header of headers) {
+      // "ice-ufrag" and "ice-pwd" attributes convey the username fragment and
+      // password used by ICE for message integrity. See RFC 5245, Section 15.4.
+      if (header.startsWith("a=ice-ufrag")) {
+        // e.g. [a=ice-ufrag:0c838e8e]
+        ufrag = header.slice(header.indexOf(":") + 1);
+      }
+      else if (header.startsWith("a=ice-pwd")) {
+        // eg. [a=ice-pwd:1ef8fe1ef670d3dd89098b03dac4b4ed]
+        pwd = header.slice(header.indexOf(":") + 1);
+      }
+      else if (header.startsWith("a=fingerprint")) {
+        // e.g. [a=fingerprint:sha-256 2B:6E:6A:8D:...]
+        [hashType, fingerprintData] =
+          header.slice(header.indexOf(":") + 1).split(" ");
       }
     }
 
-    // If the session descrription lacks session-level section's information the
-    // media-level section shouldn't be parsed.
-    if (!(ufrag && pwd && shaHash && fingerprintData))
-      return;
+    // If we don't have the required information from the header, don't bother
+    // parsing media sections.
+    if (!(ufrag && pwd && hashType && fingerprintData))
+      return null;
 
-    /* Divide the media type audio/video into set of groups containing the
-     * payload and candidate information of the respective media found. The
-     * sessionDesc array now contains only the media-level section elements.
-     */
-    sessionDesc.shift();
+    // Now transform each media section to Jingle stanzas.
+    let contentNodes = [];
+    for (let medium of sections) {
+      let lines = medium.split("\r\n");
+      let mediaName = lines[0].split(" ")[0];
 
-    // For each media a content node containing description and transport child
-    // node is to be created.
-    for (let medium of sessionDesc) {
-      let mediaLines = medium.split("\r\n");
-      let mediaName = mediaLines[0].split(" ")[0];
-
-      // Set the name attribute of content node.
       let nameAttr;
       if (mediaName == "audio")
         nameAttr = "voice";
       else if (mediaName == "video")
         nameAttr = "face";
-      // Do not send the content node if the m=… contains media name other than
-      // audio or video.
-      else
+      else // ignore sections that are neither audio nor video.
         continue;
 
-      // Content node is added to content.
       let content = Stanza.node("content", null,
-                                {creator: "initiator",
-                                 name: nameAttr});
+                                {creator: "initiator", name: nameAttr});
 
-      // Setup attribute of description node. Every media-level description
-      // contains a=setup field whose value is set as the setup attribute.
+      // Every media section contains an a=setup line with a value that's
+      // one of: actpass / active / passive.
       let setupAttr = medium.match(/(a=setup)[\S]*/)[0].split(":")[1];
-      // Set attributes for the description node.
+
       let description = Stanza.node("description", null,
                                     {xmlns: Stanza.NS.jingle_apps_rtp,
-                                     // Sets media as audio or video.
                                      media: mediaName,
-                                     // setup=actpass / active / passive.
                                      setup: setupAttr});
       content.addChild(description);
 
-      // Transport element is a child of content node. It contains fingerprint
-      // and candidate nodes.
+      // Transport element is a child of content node. It contains a fingerprint
+      // and several candidate nodes.
       let transport = Stanza.node("transport", null,
                                   {xmlns: Stanza.NS.jingle_transport_ice_udp,
                                    ufrag: ufrag,
                                    pwd: pwd});
       content.addChild(transport);
 
-      // Fingerprint element.
-      let fingerprint = Stanza.node("fingerprint", null,
-                                    {xmlns: Stanza.NS.jingle_apps_dtls,
-                                     hash: shaHash},
-                                    // Fingerprint data.
-                                    fingerprintData);
-      transport.addChild(fingerprint);
+      transport.addChild(Stanza.node("fingerprint", null,
+                                     {xmlns: Stanza.NS.jingle_apps_dtls,
+                                      hash: hashType},
+                                     fingerprintData));
 
-      let payloads = [];
+      let lastPayload;
 
-      for (let mediaField of mediaLines) {
-        let params = mediaField.split(" ");
-        let pNode = params[0].split(":");
+      for (let line of lines) {
 
-        /* XEP: 2094 Jingle RTP Header Extensions Negotiation. It defines
-         * backward-compatible and extensible means to carry multiple header
-         * extension elements in a single RTP packet. This header extension
-         * applies to RTP/AVP (Audio/Visual Profile) and its extensions.
-         * e.g. [ a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level].
-         * Here 1 is the local ID and the next is URI for the extension.
-         * It is to be mapped with the rtp-hdrext node.
-         */
-        if (pNode[0] == "a=extmap") {
-          description
-            .addChild(Stanza.node("rtp-hdrext", null,
-                                  {xmlns: Stanza.NS.jingle_apps_rtp_hdrext,
-                                   id: pNode[1],
-                                   uri: params[1]}));
+        // parseParams will return an array of the space-separated
+        // parameters after the ':' on the line variable.
+        let parseParams = () => line.slice(line.indexOf(":") + 1).split(" ");
+
+        if (line.startsWith("a=extmap")) {
+          // XEP: 0294 Jingle RTP Header Extensions Negotiation.
+          // e.g. [ a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level].
+          let [id, uri] = parseParams();
+          description.addChild(Stanza.node("rtp-hdrext", null,
+                                           {xmlns: Stanza.NS.jingle_apps_rtp_hdrext,
+                                            id: id, uri: uri}));
         }
-        /* Payload-type node is child of description node. This attribute
-         * maps from an RTP payload type number (as used in an "m=" line)
-         * to an encoding name denoting the payload format to be used.
-         * e.g. [a=rtpmap:8 PCMA/8000/2]
-         */
-        else if (pNode[0] == "a=rtpmap") {
-          let payloadAttr = params[1].split("/");
-          // If channel information is missing in the payload type pass
-          // without channel attribute.
-          let attr = {id: pNode[1], name: payloadAttr[0],
-                      clockrate: payloadAttr[1]};
-          if (payloadAttr.length >= 3)
-            attr.channels = payloadAttr[2];
+        else if (line.startsWith("a=rtpmap")) {
+          // e.g. [a=rtpmap:8 PCMA/8000/2]
+          let [id, value] = parseParams();
+          let values = value.split("/");
 
-          payloads.push(Stanza.node("payload-type", null, attr));
+          let attr = {id: id, name: values[0], clockrate: values[1]};
+          // channel information is optional.
+          if (values.length >= 3)
+            attr.channels = values[2];
+
+          lastPayload = Stanza.node("payload-type", null, attr);
+          description.addChild(lastPayload);
         }
-        /* The ping time information if present should be added as the child
-         * of payload-type. This gives the length of time in milliseconds
-         * represented by the media in a packet. Since a=ptime appears just
-         * above concerned payload-type we add it as children to the payload
-         * node created just before.
-         */
-        else if (pNode[0] == "a=ptime") {
-          let parameter = Stanza.node("parameter", null,
-                                      {ptime: pNode[1]});
-          payloads[payloads.length - 1].addChild(parameter);
+        else if (line.startsWith("a=ptime")) {
+          // This gives the length of time in milliseconds represented by the
+          // media in a packet. It applies to the payload node created before.
+          lastPayload.addChild(Stanza.node("parameter", null,
+                                           {ptime: parseParams()[0]}));
         }
-        /* a=fmtp field allows parameters that are specific to a particular
-         * format to be conveyed in a way that SDP does not have to understand
-         * them. This is added in same manner as a=ptime.
-         */
-        else if (pNode[0] == "a=fmtp") {
-          let parameter = Stanza.node("parameter", null,
-                                      {value: params[1]});
-          payloads[payloads.length - 1].addChild(parameter);
+        else if (line.startsWith("a=fmtp")) {
+          // a=fmtp field allows parameters that are specific to a particular
+          // format to be conveyed in a way that SDP does not have to understand
+          // them. This is added in same manner as a=ptime.
+          // TODO parameter 1 is the id of the rtpmap this applies too;
+          // we currently just assume the rtpmap is the previous payload.
+          lastPayload.addChild(Stanza.node("parameter", null,
+                                           {value: parseParams()[1]}));
         }
-        /* XEP: 2093 Jingle RTP Feedback Negotiation. It is uses a modified
-         * RTP profile for audio and video conferences with minimal control
-         * to acieve timely feedback.
-         * e.g. [a=rtcp-fb:98 nack rpsi]
-         * Here rtcp-fb is inserted in the payload-type node with the id 98.
-         * It contains the type "nack" and subtype "rpsi".
-         */
-        else if (pNode[0] == "a=rtcp-fb") {
-          let attr = {xmlns: Stanza.NS.jingle_apps_rtcp_fb, type: params[1]};
-          if (params.length >= 3)
-            attr.subtype = params[2];
+        else if (line.startsWith("a=rtcp-fb")) {
+          // XEP: 0293 Jingle RTP Feedback Negotiation.
+          // e.g. [a=rtcp-fb:98 nack rpsi]
+          let values = parseParams();
 
-          payloads[payloads.length - 1]
-            .addChild(Stanza.node("rtcp-fb", null, attr));
+          // TODO: values[0] is the id of the rtpmap this applies to;
+          // we currently just assume the rtpmap is the previous payload.
+          let attr = {xmlns: Stanza.NS.jingle_apps_rtcp_fb, type: values[1]};
+          if (values.length >= 3)
+            attr.subtype = values[2];
+
+          lastPayload.addChild(Stanza.node("rtcp-fb", null, attr));
         }
-        /* Candidate nodes are added as child of the transport node. It is
-         * explained in RFC-5245: Interactive Connectivity Establishment(ICE).
-         * e.g. [a=candidate:3 2 UDP 1686044670 106.51.45.18 43127 typ host]
-         */
-        else if (pNode[0] == "a=candidate") {
-          let attr = {component: pNode[1], foundation: params[1],
-                      protocol: params[2], priority: params[3], ip: params[4],
-                      port: params[5], type: params[7]};
-          if (params.length >= 9) {
-            attr.reladdr = params[9];
-            attr.relport = params[11];
+        else if (line.startsWith("a=candidate")) {
+          // e.g. [a=candidate:3 2 UDP 1686044670 106.51.45.18 43127 typ host]
+          let values = parseParams();
+          let attr = {component: values[0], foundation: values[1],
+                      protocol: values[2], priority: values[3], ip: values[4],
+                      port: values[5], type: values[7]};
+          if (values.length >= 9) {
+            attr.reladdr = values[9];
+            attr.relport = values[11];
           }
 
           transport.addChild(Stanza.node("candidate", null, attr));
         }
       }
 
-      // Add the payload nodes as children to the description node.
-      payloads.forEach(function(aPayload) description.addChild(aPayload));
       contentNodes.push(content);
     }
 
     return contentNodes;
   },
 
-  xml2sdp: function xml2sdp(aXmlOffer) {
-    if (aXmlOffer.length === 0)
-      return;
+  xml2sdp: function xml2sdp(aJingleContentNodes) {
+    if (!aJingleContentNodes.length)
+      return null;
 
-    let sdp = [];
-    let nodeContent = [];
-
-    /* Complete SDP session-level description should be generated. Since there
-     * is no mention in the XEPs about how to pass v=, o=, s= and t= fields in
-     * form of XML stanzas we have given a constant value to each of these
-     * fields. Note that these value don't affect the call being made.
-     */
-    let header = ["v=0",
-                  "o=Mozilla-SIPUA 0 0 IN IP4 0.0.0.0",
-                  "s=SIP Call",
-                  "t=0 0"];
-    sdp.push(header.join("\r\n"));
+    // Parts of the header (v=, o=, s= and t= fields) are not passed as part of
+    // the XMPP stanza.
+    let sdp = ["v=0",
+               "o=Mozilla-SIPUA 0 0 IN IP4 0.0.0.0",
+               "s=SIP Call",
+               "t=0 0"];
 
     // Transport node contains ufrag, pwd, fingerprint.
-    let eleTransport = aXmlOffer[0].getElement(["transport"]);
-    let eleFingerprint = eleTransport.getElement(["fingerprint"]);
+    let transport = aJingleContentNodes[0].getElement(["transport"]);
+    if (!transport)
+      return null;
 
-    sdp.push("a=ice-ufrag:" + eleTransport.attributes["ufrag"]);
-    sdp.push("a=ice-pwd:" + eleTransport.attributes["pwd"]);
+    sdp.push("a=ice-ufrag:" + transport.attributes["ufrag"]);
+    sdp.push("a=ice-pwd:" + transport.attributes["pwd"]);
 
-    if (eleFingerprint) {
-      sdp.push("a=fingerprint:" + eleFingerprint.attributes["hash"]  + " " +
-               eleFingerprint.innerText);
+    let fingerprint = transport.getElement(["fingerprint"]);
+    if (fingerprint) {
+      // XXX Should we warn if fingerprint is missing?
+      sdp.push("a=fingerprint:" + fingerprint.attributes["hash"]  + " " +
+               fingerprint.innerText);
     }
 
-    /* The content node is used to form the media element of the offer.
-     * i.e. It contains m=, c=, a=rtpmap, a=candidate and other atrributes
-     * which defines how that media voice/video would be mapped.
-     */
-    for (let cNode of aXmlOffer) {
-      let media = [];
+    // The content node is used to form the media element of the offer. I.e. it
+    // contains m=, c=, a=rtpmap, a=candidate and other attributes which define
+    // how that media voice/video are mapped.
+    for (let content of aJingleContentNodes) {
+      if (content.qName != "content")
+        continue;
+
+      let description = content.getElement(["description"]);
+      if (!description)
+        continue;
+
       // Media is of the form [m=video 33680 RTP/SAVPF 120].
-      let descData = cNode.getElement(["description"]);
-      media.push(("m=" + descData.attributes["media"]));
+      let media = "m=" + description.attributes["media"];
 
       // Connection element (IP is first IP of candidate).
       // e.g. [c=IN IP4 106.51.45.18]
-      let firstCandidateData = cNode.getElement(["transport"])
-                                    .getElement(["candidate"]);
+      let transport = content.getElement(["transport"]);
+      if (!transport)
+        continue;
 
-      // The port attribute of first candidate is used if no relport exist. Else
-      // use the first relport found in other candidate of the media.
-      media.push(firstCandidateData.attributes["port"], "RTP/SAVPF");
+      let candidates = transport.getElements(["candidate"]);
+      // The media line contains the real port, if we can find one.
+      let port;
+      for (let candidate of candidates) {
+        if (candidate.attributes["relport"]) {
+          port = candidate.attributes["relport"];
+          break;
+        }
+      }
+      // The port of the first candidate is used if no relport exists.
+      if (!port)
+        port = candidates[0].attributes["port"];
 
-      let connection = "c=IN ";
-      let IP = firstCandidateData.attributes["ip"];
-      if (IP.contains(":"))
-        connection += "IP6 " + IP;
+      media += " " + port + " RTP/SAVPF";
+
+      let connection = "c=IN IP";
+      // XXX Using the ip from the first candidate doesn't seem perfect...
+      let ip = candidates[0].attributes["ip"];
+      if (ip.contains(":"))
+        connection += "6 " + ip;
       else
-        connection += "IP4 " + IP;
-      nodeContent.push(connection);
-
-      // The c=IN... line must be added just below the m=… line. indexConnection
-      // stores the index of last occurence of c=... element in the SDP offer.
-      let indexConnection = nodeContent.lastIndexOf(connection);
+        connection += "4 " + ip;
+      let section = [connection];
 
       // Payload element [a=rtpmap:8 PCMA/8000].
-      let payloadData = descData.getElements(["payload-type"]);
-      let payload;
-      let indexSendrecv;
-      for (let pNode of payloadData) {
-        payload = "a=rtpmap:" + pNode.attributes["id"] + " " +
-                  pNode.attributes["name"] + "/" + pNode.attributes["clockrate"];
-        if (pNode.attributes["channels"])
-          payload += "/" + pNode.attributes["channels"];
+      let payloadNodes = description.getElements(["payload-type"]);
+      for (let payloadNode of payloadNodes) {
+        let payload = "a=rtpmap:" + payloadNode.attributes["id"] + " " +
+          payloadNode.attributes["name"] + "/" + payloadNode.attributes["clockrate"];
+        if (payloadNode.attributes["channels"])
+          payload += "/" + payloadNode.attributes["channels"];
+        section.push(payload);
 
         // Push payload-type ID to media.
-        media.push(pNode.attributes["id"]);
+        media += " " + payloadNode.attributes["id"];
 
-        nodeContent.push(payload);
-        indexSendrecv = nodeContent.lastIndexOf(payload);
-
-        if (pNode.getElement(["parameter"])) {
-          let parameter = pNode.getElement(["parameter"]);
-
+        let parameter = payloadNode.getElement(["parameter"])
+        if (parameter) {
           // Ping element.
-          if (parameter.attributes["ptime"]) {
-            nodeContent.push("a=ptime:" + parameter.attributes["ptime"]);
-            indexSendrecv = nodeContent.length;
-          }
+          if (parameter.attributes["ptime"])
+            section.push("a=ptime:" + parameter.attributes["ptime"]);
           // Additional parameter to be added if specified.
           else if (parameter.attributes["value"]) {
-            nodeContent.push("a=fmtp:" + pNode.attributes["id"] + " " +
-                             parameter.attributes["value"]);
-            indexSendrecv = nodeContent.length;
+            section.push("a=fmtp:" + payloadNode.attributes["id"] + " " +
+                         parameter.attributes["value"]);
           }
         }
 
         /* rtcp-fb element defined in XEP: 2093 Jingle RTP Feedback Negotiation
          * uses a modified  RTP profile for audio and video conferences with
          * minimal control to acieve timely feedback.
          */
-        let rtcpfbData = pNode.getElements(["rtcp-fb"]);
-        if (rtcpfbData) {
-          for (let rNode of rtcpfbData) {
-            let rtcpfb = "a=rtcp-fb:" + pNode.attributes["id"] + " " +
-                         rNode.attributes["type"];
-            if (rNode.attributes["subtype"])
-              rtcpfb += " " + rNode.attributes["subtype"];
+        let rtcpFbData = payloadNode.getElements(["rtcp-fb"]);
+        for (let rNode of rtcpFbData) {
+          let rtcpFb = "a=rtcp-fb:" + payloadNode.attributes["id"] + " " +
+            rNode.attributes["type"];
+          if (rNode.attributes["subtype"])
+            rtcpFb += " " + rNode.attributes["subtype"];
 
-            nodeContent.push(rtcpfb);
-          }
+          section.push(rtcpFb);
         }
       }
+
       // Push a=sendrecv just after the last payload type element.
-      nodeContent.splice(indexSendrecv + 1, 0, "a=sendrecv");
+      section.push("a=sendrecv");
 
       // rtp-hdrext element.
       // e.g. [a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level].
-      let rtpContent = descData.getElement(["rtp-hdrext"]);
-
+      let rtpContent = description.getElement(["rtp-hdrext"]);
       if (rtpContent) {
-        let rtphdrext = "a=extmap:" + rtpContent.attributes["id"]  + " " +
+        let rtpHdrext = "a=extmap:" + rtpContent.attributes["id"]  + " " +
                         rtpContent.attributes["uri"];
-
-        nodeContent.push(rtphdrext);
+        section.push(rtpHdrext);
       }
 
       // Setup attribute of description [a=setup:actpass].
-      if (descData.attributes["setup"])
-        nodeContent.push("a=setup:" + descData.attributes["setup"]);
+      if (description.attributes["setup"])
+        section.push("a=setup:" + description.attributes["setup"]);
 
       // Candidate elements.
       // e.g. [a=candidate:0 1 UDP 2122252543 106.51.45.18 60055 typ host].
-      let candidateData = cNode.getElement(["transport"])
-                               .getElements(["candidate"]);
-      let relport = [];
-
-      for (let candNode of candidateData) {
-        let candidate = "a=candidate:" + candNode.attributes["component"] + " " +
-                        candNode.attributes["foundation"] + " " +
-                        candNode.attributes["protocol"] + " " +
-                        candNode.attributes["priority"] + " " +
-                        candNode.attributes["ip"] + " " +
-                        candNode.attributes["port"] +
-                        " typ " + candNode.attributes["type"];
-        if (candNode.attributes["relport"]) {
-          candidate += " raddr " + candNode.attributes["reladdr"] +
-                       " rport " + candNode.attributes["relport"];
-          // Store the values of relport so that if relport exist the
-          // media[1] could be replaced with relport[0].
-          relport.push(candNode.attributes["relport"]);
+      for (let node of candidates) {
+        let candidate = "a=candidate:" +
+                        node.attributes["component"] + " " +
+                        node.attributes["foundation"] + " " +
+                        node.attributes["protocol"] + " " +
+                        node.attributes["priority"] + " " +
+                        node.attributes["ip"] + " " +
+                        node.attributes["port"] +
+                        " typ " + node.attributes["type"];
+        if (node.attributes["relport"]) {
+          candidate += " raddr " + node.attributes["reladdr"] +
+                       " rport " + node.attributes["relport"];
         }
 
-        if (relport[0])
-          media[1] = relport[0];
-
-        nodeContent.push(candidate);
+        section.push(candidate);
       }
 
-      // This is used to construct the m=… line of the SDP offer. It puts the
-      // media line constructed just above the c=… line.
-      nodeContent.splice(indexConnection, 0, media.join(" "));
+      // Add the media element as the first part of this section.
+      section.unshift(media);
+
       // Taking [a=rtcp-mux] as default. Suitable XML element is not defined.
       // Most of the devices have rtcp-mux in their offer.
-      nodeContent.push("a=rtcp-mux");
+      section.push("a=rtcp-mux");
+
+      // Add this section to the full SDP.
+      sdp.push(...section);
     }
 
-    sdp.push(nodeContent.join("\r\n"));
     return sdp.join("\r\n");
   }
 };
